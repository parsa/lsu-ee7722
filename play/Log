:: 21 January 2008, 19:08:38 CST

Optimizing cube 4.

Initial, 100  per face.
5.2 us

Call use program lazily.
3.1 us

Only upload some uniforms once per face.
2.7 us

Application not optimized.
2.8 us

Immediate return from circle
0.5 us

Return just before glBegin
0.5 us

Use fixed circle:
2.2 us
2.5 ms

Only upload some uniforms once per face. (Repeat, but with cpu)
2.8 us
3.1 ms

Only upload some uniforms once per face. Get cpu time before gpu query.
2.8 us
2.8 ms

Use fixed circle.
2.2 us
2.2 ms

Only update texture center once per frame (it will be incorrect).
2.8 us
2.7 ms

No uniforms.
2.1 us
2.0 ms

Immediate Return
0.5
0.8

Return just before begin/end
0.5
0.8

Execute begin/end without vertices.
1.3
1.6

Use DrawArrays, no uniforms
1.9
1.8

Use DrawArrays, uniforms for tex ctr, circle center
2.7
2.6

Make circle center and tex_ctr an attribute.
1.9
1.8

Use draw arrays for fixed circle.
1.9
1.8

Bumps, x 20

Original Code (vertex3)
8.4
8.5

Using Arrays ??? (vertex4)
9.1
9.4

Using arrays, omitting normals. (vertex3)
8.2
8.7

:: 23 January 2008, 19:11:45 CST

Repeat timing experiments after using texgen and using
a face-forward transformation.

Fixed function circle (x100)
1.8 us GPU
1.6 ms CPU

With shader
2.0
1.9

Bumps, x20

Fixed function (circle & bump)  No normals.
5.1
5.6

:: 24 January 2008,  9:48:13 CST

Fixed a few random things.
Lighting shader used when bump computed by CPU.
Bumps, x20

CPU Bumps
5.3 us
5.6 ms

GPU Bumps
3.1 us
3.2 ms

Include normal calculations. CPU does it per vertex, CPU per quad.

CPU Bumps:
3.7
3.8

GPU Bumps
3.2
3.3

Use just one attribute array.

GPU Bumps
3.0
3.1

With 30 radial steps.  GPU
7.1
7.2

GPU don't send unchanging attributes as array. 
4.6
4.7

Fixed
9.8
9.8

GPU, don't even update pinnacle array in loop.
3.9
4.1

GPU, Just send theta and eta in vertex.
2.4
2.5

GPU, only update array once, but keep sending to gpu
2.3
2.1

GPU, use buffer object for vertices.
1.2
1.1

GPU, immediate return from bump render.
0.6
0.9

CPU, return after preparing data, but without graphics calls.
0.6
7.0

::  2 February 2008, 19:48:36 CST

g_prv.velocity
g_prv.position
g_prv.force

g.velocity (estimated)
g.position Computed using estimated velocity?
g.force = blah blah

g.velocity = g_prv.velocity + 



g_next.position = g.velocity * delta_t..


g_nxt

:: 25 February 2008, 17:42:31 CST

Cube5 To Do:

GPU / CPU Time.

Send vertex info in bunches.

::  2 March 2008, 12:03:18 CST
::  3 March 2008,  8:18:51 CST


Cube 5 Tuning.

All timings below for gpu use.

CPU 3.65 ms

Use buffer object for texture coordinates.

CPU 3.65

Don't update color and normal arrays (but still use).
CPU 3.0

Don't update color and normal arrays and don't use either.
CPU 2.9

Don't update color and normal arrays and don't use either. 
Send 1/2 of the triangles.
CPU 2.85

Don't update color and normal arrays and don't use either. 
Send 1/2 of the triangles.
Only render 1/2 faces.
CPU 2.65

Render 0 faces.
CPU: 2.55

Render 0 faces.
Paused
CPU: .67

Render all faces, all triangles, but still no color or normal.
Paused:
CPU: 1.0

Render all faces, all triangles, but still no color or normal.
CPU: 3.0

Render everything again, but still don't update colors and normals.
CPU: 3.05
Paused:
CPU: 1.1
-> Physics = 1.95

Without GPU Physics
CPU: 4.8
Paused:
CPU: 1.1
-> Physics = 3.7

Note: Per time steps below omits constant overhead. (t1-t2)/(n1-n2)

Render everything again, including normals and colors.
Baseline: 5 ts / frame
CPU: 3.7 ms
GPU: 3.9 us

Doubled to 600 time steps / s
CPU: 4.3
GPU: 4.6
Per time step, cpu: 0.12 ms / ts
Per time step, gpu: 0.14 us / ts

To 1200 time steps / s
CPU: 5.7
CPU: 6.1
Per time step: 0.133 / ts
Per time step, gpu: 0.147 us / ts

Paused:
CPU: 1.7
GPU: 1.1


Use vertex shader for normals and colors, just use buffer objects
but still shuttle data between GPU and CPU each frame.
CPU: 2.7
GPU: 2.9

At 600 ts / s
CPU: 3.4
GPU: 3.6
Per time step, cpu: 0.14 / ts

At 1200 ts / s
CPU: 5.0
GPU: 5.0

Per time step, cpu: 0.153 / ts

Just transfer current buffer from gpu to cpu for each frame.
CPU: 2.3
GPU: 2.4

Don't transfer buffer unless data is needed at destination.
CPU: 1.6
GPU: 1.7

Grid size 30 -> 60
CPU: 2.6
GPU: 2.7

:: 28 September 2009, 12:03:03 CDT

Bouncing ball demo to do:

Take into account delta_t when applying friction.

In ball collision, check for angular and linear momentum conservation.
For ball penetration account for exact time balls intersect.
Find a better model for collision energy loss. 
>Account for torque in ball penetration.
>Use penetration's collision model in platform collision code.

Combine rotation axis and rate.

Pre-compute factors.

Determine relative cost of display and physics.

CUDA

CPU

1.60 Use ball penetration for platform coll.
2.38 Alternate handling of rolling friction. Temporary validation code?
2.30 Remove test of apply deltao.
1.64 Remove to/from am in penetration routine.
1.56 Only use to/from to compute the rotation vector.
1.52 No to/from, use pnorm for computing rotation matrix.
1.47 Don't rotate orientation of mo magnitude very low.
1.43 Use precomputed two_r_sq to rule out contact.
1.41 A few pre-computed constants.
1.38 No verification.
1.36 For rolling friction add mo only after looking at both balls.
(1.24 -.18 No rolling friction.)
(1.27 -.09 Don't recompute orientation matrix.)
1.30 Don't sort by bogus contact time.
(1.35 sort contact list twice.)
1.29 Make region length two_r, don't initialize unused members.
(1.08 Ball render: 0.42;  Only render very other ball.)
1.20 Use single triangle strip for ball.
1.17 Use 3x3 matrix multiply.
(1.04 No rolling friction: 0.13.)
(0.87 No torque of any kind: 0.30 )
1.20 Occlusion queries.

1.69 320 time steps / s. => 0.52 per time steps, 0.65 per render.

Torq   Rend   ????
0.36 + 0.33 + 0.48

::  4 October 2009, 14:27:53 CDT

Balls now have angular momentum.
A drip mode for watching balls accumulate in a sheet.
Use occlusion test to avoid rendering hidden balls.
Many other improvements.

:: 11 October 2009,  8:56:39 CDT

cuda-util.h
Added header.
Include cuda_runtime.h and cuda_gl_interop.h
pCUDA_Memory: 
 Deallocate cuda memory when destructor called.
 New: ptrs_to_cuda_side, ptrs_to_cuda
 Initialize locked.
pCUDA_Memory_X: Use pCUDA_Memory::ptrs_to_cuda_side.

:: 13 October 2009, 18:03:25 CDT


xf 7  cu 16.8  cpu 100.8  
xf 7  cu 16.8  cpu  99.0  Increase sm storage from 1000 to 16000.
xf x  cu  9.3  cpu  47.7  Turn on optimization.
xf 1  cu ----  cpu   6.8  Turn off cuda.
xf 3  cu  7.4  cpu  36.7  Don't reallocate cuda buffers each time step.
xf 1  cu  2.5  cpu   6.8  Update schedule every (3) time steps.
xf 1  cu  2.3  cpu   5.2  Update schedule every (10) time steps.
xf 1  cu  1.8  cpu   4.9  Only send data to cuda when stale.
xf 1  cu  1.5  cpu   4.5  Only retrieve all cuda data when ready to render.
xf 1  cu  1.2  cpu   4.2  Base interaction region on max ball speed.

:: 26 October 2009, 12:59:34 CDT

Solve[ (m2 - m2 m1 ) u^4 + ( 2 m1 - 2 m1^2 + 2 e^2 + 2 m2^2 ) u^3 + 6 u^2 m2 m1 + ( -2 m2^2 + 2 m1^2 + 2 m1 - 2 e^2 ) u - m2 m1 - m2 == 0,u]

:: 29 October 2009, 18:20:36 CDT

Check in shader changes.
Move quats to coor.

:: 30 October 2009, 18:07:52 CDT

To Do:

Update comments on render routine.
Finish comments on time-step CPU
Document physics variables.
Finish organizing World structure.
Move out CUDA support code.
Separate occlusion test for reflections.

::  2 November 2009,  9:24:47 CST

Warmup...


Physics

Overview

 


Rendering

Code Organization

Shaders

::  3 November 2009, 14:21:42 CST

To Do:

Remove CUDA code.
>Document user modifiable variables.
>Make sure each file has comments header.
